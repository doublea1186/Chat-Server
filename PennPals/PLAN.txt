=:=:=:=:=:=:=:=:=:=:=:=:=:=:=:=:=:=:=
CIS 120 Homework 7 README
PennKey: 69756235
=:=:=:=:=:=:=:=:=:=:=:=:=:=:=:=:=:=:=

============
=: Task 2 :=
============

- Do you plan on creating any new classes in your design? If so, what classes
  are you making, what do they store, and what behaviors do they have?
  	I plan on making a class for channels.
  	The class for channels will store the String name, String owner, inviteOnly boolean, and a TreeMap of users in the channel.
  	You can add users, remove users, initialize the owner and name. I only make a class for channels because channels have to
  	keep track of more than just nicknames and ids and thus a new class is a good idea for them.

- How do you plan on storing what users are registered on the server?
	I plan on storing them in a treeMap in which the keys is the integer ID and the value is the nickname in the serverModel 
	class. 

- How do you plan on keeping track of which user has which user ID, considering
  the fact that the user's nickname can change over the course of the program?
  	The TreeMap's key is going to be the user's ID so it will be mapped to each respective user's nickname. 
  	UserIds cannot be repeated but nicknames can be changed so that is why I decided to use a TreeMap since we can
  	change the value of a key. 

- How do you plan on storing what users are in a channel?
	The channel class contains this data in a TreeMap in the serverModel in which the IDs are the keys and the nicknames are
	the values. 

- How do you plan on keeping track of which user is the owner of each channel?
	The channel class contains this data as a parameter as a string and it can't change. 

- Justify your choice of collections (Set, Map, or List) for the
  collections you use in your design.
	I use TreeMaps for storing data because they are the most efficient in terms of search and the functionality
	offered by the .keySet(), .values(), .put() and .remove() methods are quite useful in implementation. 
	Using a TreeMap to search the channel's by name and for searching the users by username is the optimal method
	considering the limited data structures we are allowed to use. Whenever I have to return a list of nicknames or ids I 
	simply use the .keySet() or .values() methods to do it simply and I use the .addAll() function to make copies of 
	data to return them so that the ServerModel Class is safe. 

============
=: Task 3 :=
============

- Did you make any changes to your design while doing this task? Why?
	No, I found it quite easy to implement this task given my design that I initially created. I used the functions 
	in ServerModel we were told to implement, along with my channel class, both of which are decently loosely modular
	and implemented task three with these tools. The hard part about this task was ensuring that everything gets updated correctly
	when a user changes his or her nickname in all the channels and such. 

============
=: Task 4 :=
============

- Did you make any changes to your design while doing this task? Why?
	No, I once again found it quite easy to implement this task given my design that I initially created. Nothing was
	unexpectedly difficult and I knew on an abstract level how to implement most things from the class and function definitions.
    The trickiest part of this task was handling whether or not the channel was private or public and the subsequent 
    logic associated with that since I accounted for the invite parameter of task 5. 


============
=: Task 5 :=
============

- How do you plan on keeping track of which channels are invite-only?
	There is an inviteOnly parameter for my channel class which will tell me if a channel is invite only or no. 

- Will you make any changes to your work from before in order to make
  implementing invite-only channels easier?
  When I initially made my channel class I made sure to account for the invite only parameter
  so no I will not make any changes to my class, however I will be adding a parameter to the KickUserFromChannel 
  function. That parameter is the person asking to kick the user so that I can implement logic based on the 
  channel being invite only and subsequently who the owner is from it. This command removes the person from the channel if 
  the person making the request is the owner. I also created another function for inviting people to private channels as well 
  to account for the new error cases introduced and to handle the logic efficiently. 
  


============
=: Task 6 :=
============

- Did you have to make any changes to your design in Task 6? Why?
	I did not make any major changes. It was mostly just style clean up, small bug fixes with who the recipients were etc. 
	Throughout the project I constantly thought about the most efficient implementation of functions and to make sure that my 
	new code can build on older code easily. I am sure I definitely could make my code better but at this point I am not entirely
	sure what else I could do. 

- If you were to redo this assignment, what changes (if any) would you make in
  how you designed your code?
  Maybe I would consider code run time in my assignment and try to implement more efficient algorithms so that
  my code runs faster and is not as inefficient at times. I would probably also try to make my code even more loosely modular
  so that I can reuse code more often and save myself work and time. 

